use super::math::{round_up_2, trailing_zero_right};

use std::alloc::{AllocError, Layout};
use std::mem::forget;
use std::ptr::NonNull;
use std::sync::Mutex;

const MIN_BUDDY_SIZE: usize = 64;
const MAX_BUDDY_SIZE: usize = 0x2000_0000;
const MAX_SUPPORTED_ALIGN: usize = 4096;

/// Use only for static allocation
#[repr(align(4096))]
pub struct StaticChunk<const SIZE: usize>(pub [u8; SIZE]);

/// Helper to create static const chunks for allocations
/// Be carefull, static chunks affect hugely the executable's size
pub const fn create_static_chunk<const SIZE: usize>() -> StaticChunk<SIZE> {
    let mut area: [u8; SIZE] = [0; SIZE];
    // TODO: Problem with alignement check ?!?
    forget(BuddyAllocator::new(&mut area));
    StaticChunk(area)
}

/// Buddy Allocator
#[repr(C, align(16))]
pub struct BuddyAllocator<'a>(pub Mutex<ProtectedAllocator<'a>>);

impl<'a> BuddyAllocator<'a> {
    /// Create a new Buddy Allocator on a previous allocated block
    pub const fn new(address: &'a mut [u8]) -> Self {
        Self(Mutex::new(ProtectedAllocator::new(address)))
    }
    /// Attach a previously allocated chunk generated by create_static_memory_area()
    pub const fn attach_static_chunk<const SIZE: usize>(
        address: &'a mut StaticChunk<SIZE>,
    ) -> Self {
        Self(Mutex::new(ProtectedAllocator::attach_static_chunk(address)))
    }
}

// TODO. on final time, this struct must be placed into a choosen memory location
// TODO. Must be set as private
pub struct ProtectedAllocator<'a>(pub &'a mut [u8]);

macro_rules! max {
    ($x: expr) => ($x);
    ($x: expr, $($z: expr),+) => {{
        let y = max!($($z),*);
        if $x > y {
            $x
        } else {
            y
        }
    }}
}

macro_rules! min {
    ($x: expr) => ($x);
    ($x: expr, $($z: expr),+) => {{
        let y = min!($($z),*);
        if $x < y {
            $x
        } else {
            y
        }
    }}
}

impl<'a> ProtectedAllocator<'a> {
    const fn new(address: &'a mut [u8]) -> Self {
        assert!(address.len() <= MAX_BUDDY_SIZE); // Max limitation cf. 32b systems
        assert!(address.len() >= MIN_BUDDY_SIZE * 2);
        let space_rounded_up_2 = round_up_2(address.len() as u32);
        let space_order0_buddy = if space_rounded_up_2 == address.len() as u32 {
            address.len() as u32
        } else {
            space_rounded_up_2 >> 1
        };
        let current_align = if address.len() > MAX_SUPPORTED_ALIGN {
            MAX_SUPPORTED_ALIGN
        } else {
            address.len()
        };
        let ptr_offset = address.as_mut_ptr().align_offset(current_align);
        // On launch time with const fn feature, align_offset() doesn't works and returns USIZE::MAX
        // Trust on you
        assert!(ptr_offset == 0 || ptr_offset == usize::MAX); // Check pointer alignement
        let max_order = Order::try_from((
            BuddySize(MIN_BUDDY_SIZE as u32),
            BuddySize(space_order0_buddy),
        ))
        .ok()
        .expect("Woot ?");
        // Bytes needed:       2^(order) * 2
        // order 0.  2o        X o
        // order 1.  4o        X o + X X
        // order 2.  8o        X o + X X + X X X X
        // order 3. 16o        X o + X X + X X X X + X X X X X X X X
        // [..]
        let bytes_needed = 2_u32.pow(max_order.0) * 2;
        // Cannot use Iterator or IntoIterator in const fn, so we use the C style loop
        // An other trouble is that 'bytes_needed' depend of inputs params on const fn
        // it derives from SIZE then address.len(). So We have to hack the compiler to
        // allow 'infinite' eval limit. #![feature(const_eval_limit)] && #![const_eval_limit = "0"]
        let mut current_order = 0;
        let mut members = 2;
        // address.iter_mut().for_each(|v| {
        //      members -= 1;
        //      *v = current_order;
        //      if members == 0 {
        //         current_order += 1;
        //         members = 2_usize.pow(current_order as u32);
        //      }
        // });
        // Write original metadatas
        let mut index: usize = 0;
        while index < bytes_needed as usize {
            members -= 1;
            address[index as usize] = current_order;
            if members == 0 {
                current_order += 1;
                members = 2_usize.pow(current_order as u32);
            }
            index += 1;
        }
        // Bootstrap memory for metadata
        let mut this = Self(address.get_mut(0..space_order0_buddy as usize).unwrap());
        let metadata_chunk_size = max!(bytes_needed, MIN_BUDDY_SIZE as u32);
        let _r = this
            .alloc(
                Layout::from_size_align(metadata_chunk_size as usize, MIN_BUDDY_SIZE)
                    .ok()
                    .expect("Woot ?"),
            )
            .ok()
            .expect("Woot ?");
        this
    }
    const fn attach_static_chunk<const SIZE: usize>(chunk: &'a mut StaticChunk<SIZE>) -> Self {
        Self(&mut chunk.0)
    }
    const fn set_mark(&mut self, buddy_size: BuddySize) -> Result<NonNull<[u8]>, &'static str> {
        let order = Order::try_from((buddy_size, BuddySize(self.0.len() as u32)))?;
        let order = order.0 as u8;
        let mut index = 1; // Begin on index 1
        let mut current_order = 0;
        // TODO: Problem for order 0
        while current_order < order {
            if self.0[index] > order {
                return Err("Not enough room to swing a cat, a cat, the animal !");
            } else {
                let next_offset = index + 2_usize.pow(current_order as u32);
                index = if self.0[next_offset] <= order {
                    next_offset
                } else {
                    next_offset + 1
                }
            }
            current_order += 1;
        }
        self.0[index] |= 0x80;
        self.0[index] += 1;
        // TODO: Problem for order 0
        while index > 1 {
            if current_order == 0 {
                panic!("Sa mere");
            }
            current_order -= 1;
            let previous_offset = index - 2_usize.pow(current_order as u32);
            let parent = if index & 0b1 == 0 {
                previous_offset
            } else {
                previous_offset - 1
            };
            let next_offset = previous_offset + 2_usize.pow(current_order as u32);
            self.0[parent] = min!(self.0[next_offset], self.0[next_offset + 1]);
            index = parent;
        }
        Ok(NonNull::from(
            self.0
                .get_mut(index..index + buddy_size.0 as usize)
                .unwrap(),
        ))
    }
    fn unset_mark(&mut self, order: Order, ptr: NonNull<u8>) -> Result<(), &'static str> {
        let order = order.0 as u8;
        // TODO: Very approximative formulae, fix it
        let mut index: usize = 1
            + 2_usize.pow(order as u32) as usize
            + (((ptr.as_ptr() as usize) - (&self.0 as *const _ as usize)) % MIN_BUDDY_SIZE);
        if self.0[index] & 0x80 != 0x80 {
            Err("Double Free or corruption")
        } else {
            self.0[index] &= 0x7f;
            self.0[index] -= 1;
            let mut current_order = order;
            while index != 0 {
                let previous_offset = index - 2_usize.pow(current_order as u32);
                let parent = if index & 0b1 == 0 {
                    previous_offset
                } else {
                    previous_offset - 1
                };
                let next_offset = previous_offset + 2_usize.pow(current_order as u32);
                self.0[parent] = min!(self.0[next_offset], self.0[next_offset + 1]);
                current_order -= 1;
                index = parent;
            }
            dbg!(order);
            dbg!(ptr);
            Ok(())
        }
    }
}

// Requested Buddy Size and Order with their TryFrom<_> boilerplates
#[derive(Debug, Copy, Clone)]
struct BuddySize(u32);
#[derive(Debug, Copy, Clone)]
struct Order(u32);

impl const TryFrom<(BuddySize, BuddySize)> for Order {
    type Error = &'static str;
    #[inline(always)]
    fn try_from((buddy_size, max_buddy_size): (BuddySize, BuddySize)) -> Result<Self, Self::Error> {
        // Assuming in RELEASE profile that buddy sizes are pow of 2
        debug_assert!(round_up_2(buddy_size.0) == buddy_size.0);
        debug_assert!(round_up_2(max_buddy_size.0) == max_buddy_size.0);
        let buddy_pow = trailing_zero_right(buddy_size.0);
        let space_pow = trailing_zero_right(max_buddy_size.0);
        if buddy_pow > space_pow {
            Err("the bigger buddy is too small for the requested size")
        } else {
            Ok(Order(space_pow - buddy_pow))
        }
    }
}

// TODO: Put MAX_SUPPORTED_ALIGN & MAX_BUDDY_SIZE into static string
impl const TryFrom<Layout> for BuddySize {
    type Error = &'static str;
    #[inline(always)]
    fn try_from(layout: Layout) -> Result<Self, Self::Error> {
        match u32::try_from(max!(layout.size(), layout.align(), MIN_BUDDY_SIZE)) {
            Ok(size) if size as usize > MAX_BUDDY_SIZE => {
                Err("Size must be lower or eq than {MAX_BUDDY_SIZE}")
            }
            Ok(_size) if layout.align() > MAX_SUPPORTED_ALIGN => {
                Err("Alignement too big: MAX - {MAX_SUPPORTED_ALIGN}")
            }
            Ok(size) => Ok(BuddySize(round_up_2(size))),
            Err(_e) => Err("Requested size must be fit into an u32"),
        }
    }
}

#[allow(unused_variables)]
const fn format_error(e: &'static str) -> AllocError {
    // TODO: Problem to for using println in const FN
    // eprintln!("{}", e);
    AllocError
}

impl<'a> ProtectedAllocator<'a> {
    pub const fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        match BuddySize::try_from(layout) {
            Ok(buddy_size) => match self.set_mark(buddy_size) {
                Ok(non_null) => Ok(non_null),
                // map_err(|e| ...) doesnot works in constant fn
                Err(e) => Err(format_error(e)),
            },

            Err(e) => Err(format_error(e)),
        }
    }
    pub fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {
        match BuddySize::try_from(layout) {
            Ok(buddy_size) => match Order::try_from((buddy_size, BuddySize(self.0.len() as u32))) {
                Ok(order) => self.unset_mark(order, ptr).unwrap(),
                Err(e) => panic!("{}", e),
            },
            Err(e) => panic!("{}", e),
        }
    }
}

impl<'a> Drop for BuddyAllocator<'a> {
    fn drop(&mut self) {
        println!("Drop Called");
    }
}

impl<'a> Drop for ProtectedAllocator<'a> {
    fn drop(&mut self) {}
}

#[cfg(test)]
mod test {
    use super::Layout;
    use super::{BuddySize, Order, ProtectedAllocator};
    use super::{MAX_BUDDY_SIZE, MAX_SUPPORTED_ALIGN, MIN_BUDDY_SIZE};

    const MEMORY_FIELD_SIZE: usize = MAX_BUDDY_SIZE;
    #[repr(align(4096))]
    struct MemoryField {
        pub array: [u8; MEMORY_FIELD_SIZE],
    }
    static mut MEMORY_FIELD: MemoryField = MemoryField {
        array: [0; MEMORY_FIELD_SIZE],
    };

    mod buddy_convert {
        use super::{BuddySize, Layout};
        use super::{MAX_BUDDY_SIZE, MAX_SUPPORTED_ALIGN, MIN_BUDDY_SIZE};
        #[test]
        fn normal() {
            [
                (MIN_BUDDY_SIZE / 4, MIN_BUDDY_SIZE / 4, MIN_BUDDY_SIZE),
                (MIN_BUDDY_SIZE, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE),
                (MIN_BUDDY_SIZE / 4, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE),
                (0, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE),
                (0, MIN_BUDDY_SIZE * 2, MIN_BUDDY_SIZE * 2),
                (1, 1, MIN_BUDDY_SIZE),
                (1, MIN_BUDDY_SIZE * 2, MIN_BUDDY_SIZE * 2),
                (MIN_BUDDY_SIZE * 2 - 2, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 2),
                (MIN_BUDDY_SIZE + 1, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 2),
                (MIN_BUDDY_SIZE * 8, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 8),
                (MIN_BUDDY_SIZE * 32 + 1, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 64),
                (MIN_BUDDY_SIZE * 257, MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 512),
                (MAX_BUDDY_SIZE / 2 + 1, MAX_SUPPORTED_ALIGN, MAX_BUDDY_SIZE),
            ]
            .into_iter()
            .for_each(|(size, align, buddy_size)| {
                let layout = Layout::from_size_align(size, align)
                    .expect(format!("size {} align {}", size, align).as_str());
                assert_eq!(
                    BuddySize::try_from(layout).unwrap().0,
                    BuddySize(buddy_size.try_into().unwrap()).0,
                    "size {} align {} resulut {}",
                    size,
                    align,
                    buddy_size
                );
            });
        }
        #[should_panic]
        #[test]
        fn unsuported_align_request() {
            BuddySize::try_from(
                Layout::from_size_align(MAX_BUDDY_SIZE, MAX_SUPPORTED_ALIGN * 2).unwrap(),
            )
            .unwrap();
        }
        #[should_panic]
        #[test]
        fn unsuported_size_request() {
            BuddySize::try_from(
                Layout::from_size_align(MAX_BUDDY_SIZE + 0x1000_0000, MAX_SUPPORTED_ALIGN).unwrap(),
            )
            .unwrap();
        }
    }
    mod order_convert {
        use super::MIN_BUDDY_SIZE;
        use super::{BuddySize, Order};
        #[test]
        fn normal() {
            [
                (MIN_BUDDY_SIZE, MIN_BUDDY_SIZE, 0),
                (MIN_BUDDY_SIZE * 2, MIN_BUDDY_SIZE * 4, 1),
                (MIN_BUDDY_SIZE * 4, MIN_BUDDY_SIZE * 16, 2),
                (MIN_BUDDY_SIZE, MIN_BUDDY_SIZE * 64, 6),
                (MIN_BUDDY_SIZE * 2, MIN_BUDDY_SIZE * 64, 5),
                (MIN_BUDDY_SIZE * 64, MIN_BUDDY_SIZE * 256, 2),
                (MIN_BUDDY_SIZE * 128, MIN_BUDDY_SIZE * 256, 1),
                (MIN_BUDDY_SIZE * 256, MIN_BUDDY_SIZE * 256, 0),
            ]
            .into_iter()
            .for_each(|(curr, max, order)| {
                assert_eq!(
                    Order::try_from((BuddySize(curr as u32), BuddySize(max as u32)))
                        .expect(&format!("curr {} max {}", curr, max))
                        .0,
                    order,
                    "curr {} max {} order {}",
                    curr,
                    max,
                    order
                );
            });
        }
        #[should_panic]
        #[test]
        fn out_of_order() {
            Order::try_from((
                BuddySize(MIN_BUDDY_SIZE as u32 * 8),
                BuddySize(MIN_BUDDY_SIZE as u32 * 4),
            ))
            .unwrap();
        }
        #[should_panic]
        #[test]
        fn bad_buddy_size() {
            Order::try_from((
                BuddySize(MIN_BUDDY_SIZE as u32 * 2),
                BuddySize(MIN_BUDDY_SIZE as u32 * 8 - 4),
            ))
            .unwrap();
        }
    }
    mod constructor {
        use super::*;
        #[test]
        fn minimal_mem_block() {
            ProtectedAllocator::new(unsafe { &mut MEMORY_FIELD.array[..MIN_BUDDY_SIZE * 2] });
        }
        #[should_panic]
        #[test]
        fn too_small_mem_block() {
            ProtectedAllocator::new(unsafe { &mut MEMORY_FIELD.array[..MIN_BUDDY_SIZE] });
        }
        #[test]
        fn maximal_mem_block() {
            ProtectedAllocator::new(unsafe {
                std::slice::from_raw_parts_mut(MEMORY_FIELD.array.as_mut_ptr(), MAX_BUDDY_SIZE)
            });
        }
        #[should_panic]
        #[test]
        fn too_big_mem_block() {
            ProtectedAllocator::new(unsafe {
                std::slice::from_raw_parts_mut(
                    MEMORY_FIELD.array.as_mut_ptr(),
                    MAX_BUDDY_SIZE + 0x1000,
                )
            });
        }
        #[test]
        fn aligned_mem_block1() {
            ProtectedAllocator::new(unsafe {
                &mut MEMORY_FIELD.array[MIN_BUDDY_SIZE * 2..MIN_BUDDY_SIZE * 4]
            });
        }
        #[should_panic]
        #[test]
        fn bad_aligned_mem_block1() {
            ProtectedAllocator::new(unsafe { &mut MEMORY_FIELD.array[4..MIN_BUDDY_SIZE * 2 + 4] });
        }
        #[test]
        fn aligned_mem_block2() {
            ProtectedAllocator::new(unsafe {
                &mut MEMORY_FIELD.array[MIN_BUDDY_SIZE * 8..MIN_BUDDY_SIZE * 16]
            });
        }
        #[should_panic]
        #[test]
        fn bad_aligned_mem_block2() {
            ProtectedAllocator::new(unsafe {
                &mut MEMORY_FIELD.array[MIN_BUDDY_SIZE * 9..MIN_BUDDY_SIZE * 17]
            });
        }
        #[test]
        fn aligned_mem_block3() {
            ProtectedAllocator::new(unsafe {
                &mut MEMORY_FIELD.array[MAX_SUPPORTED_ALIGN..MAX_SUPPORTED_ALIGN * 17]
            });
        }
        #[should_panic]
        #[test]
        fn bad_aligned_mem_block3() {
            ProtectedAllocator::new(unsafe {
                &mut MEMORY_FIELD.array[(MAX_SUPPORTED_ALIGN / 2)
                    ..(MAX_SUPPORTED_ALIGN * 16) + (MAX_SUPPORTED_ALIGN / 2)]
            });
        }
    }
}
